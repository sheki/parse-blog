<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://sheki.in/favicon.ico><link rel=stylesheet href=/css/style.min.css><script type=module src=/js/vantara.js></script>
<script type=module src=http://localhost/vantara-browser-api.js></script>
<link rel=canonical href=https://sheki.in/note/education_of_a_programmer/><title>Education of a programmer</title></head><body><header id=banner><h2><a href=https://sheki.in/>shekispeaks</a></h2><nav><ul></ul></nav></header><main id=content><article><header id=post-header><h1>Education of a programmer</h1><div><time>April 13, 2017</time></div></header><p><a href=https://hackernoon.com/education-of-a-programmer-aaecf2d35312>https://hackernoon.com/education-of-a-programmer-aaecf2d35312</a></p><blockquote><p>I was at Beyond Software when I really internalized the importance of having a
singular leader over a project. The engineering manager departed (later to hire
me away for FrontPage) and all four of the leads were hesitant to step into the
role — not least because we did not know how long we were going to stick
around. We were all very technically sharp and got along well so we decided to
work as peers to lead the project. It was a mess.</p></blockquote><blockquote><p>In fact, one of our key approaches for managing complexity is to “walk away”
and start fresh. Often new tools or languages force us to start from scratch
which means that developers end up conflating the benefits of the tool with the
benefits of the clean start. The clean start is what is fundamental. This is
not to say that some new tool, platform or language might not be a great thing,
but I can guarantee it will not solve the problem of complexity growth. The
simplest way of controlling complexity growth is to build a smaller system with
fewer developers.</p></blockquote><blockquote><p>This is one of the reasons I’ve always felt Remote Procedure Call, and
especially “transparent” RPC that explicitly tries to hide the distributed
nature of the interaction, is fundamentally wrong-headed. You need to embrace
the distributed nature of the system since the implications almost always need
to be plumbed completely through the system design and into the user
experience.</p></blockquote></article></main><footer id=footer></footer></body></html>